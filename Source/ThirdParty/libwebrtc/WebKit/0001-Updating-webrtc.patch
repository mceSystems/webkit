From 97d8ac39e6fc0e8dc1b7e25a1210d6aed91fe452 Mon Sep 17 00:00:00 2001
From: Youenn Fablet <youenn@apple.com>
Date: Tue, 21 Aug 2018 14:23:22 -0700
Subject: [PATCH 1/2] Updating webrtc

---
 .../audio_codecs/ilbc/audio_encoder_ilbc.cc   |   2 +-
 .../libwebrtc/Source/webrtc/api/mediatypes.cc |   4 +-
 .../Source/webrtc/audio/remix_resample.cc     |   4 +-
 .../Source/webrtc/common_audio/wav_file.cc    |   4 +-
 .../webrtc/common_video/video_frame_buffer.cc |   2 +-
 .../Source/webrtc/media/base/codec.cc         |   4 +
 .../audio_coding/acm2/audio_coding_module.cc  |   2 +-
 .../modules/audio_coding/acm2/rent_a_codec.cc |   4 +-
 .../codecs/cng/audio_encoder_cng.cc           |   2 +-
 .../codecs/ilbc/audio_encoder_ilbc.cc         |   4 +-
 .../neteq/tools/rtp_file_source.cc            |   2 +-
 .../video_coding/codecs/vp8/include/vp8.h     |   2 +
 .../webrtc/modules/video_coding/qp_parser.cc  |   2 +
 .../video_coding/video_codec_initializer.cc   |   4 +
 .../Source/webrtc/pc/peerconnectionfactory.cc |   4 +-
 .../webrtc/pc/rtpparametersconversion.cc      |   2 +-
 .../libwebrtc/Source/webrtc/rtc_base/checks.h |   4 +-
 .../libwebrtc/Source/webrtc/rtc_base/flags.cc |   6 +-
 .../Source/webrtc/rtc_base/location.h         |   2 +-
 .../webrtc/rtc_base/logging_unittest.cc       |   2 +-
 .../rtc_base/numerics/safe_conversions.h      |   4 +-
 .../webrtc/rtc_base/opensslcertificate.cc     |   8 +-
 .../webrtc/rtc_base/physicalsocketserver.cc   |   2 +-
 .../Source/webrtc/rtc_base/stringize_macros.h |   4 +-
 .../Source/webrtc/rtc_base/task_queue_gcd.cc  |   5 +-
 .../sdk/WebKit/VideoProcessingSoftLink.h      |   2 +-
 .../sdk/WebKit/VideoToolBoxDecoderFactory.cpp |   2 +-
 .../sdk/WebKit/VideoToolBoxEncoderFactory.cpp |   3 +-
 .../webrtc/sdk/WebKit/WebKitUtilities.h       |   3 +-
 .../webrtc/sdk/WebKit/WebKitUtilities.mm      |  34 ++-
 .../Source/webrtc/sdk/WebKit/decoder.h        |   1 -
 .../Source/webrtc/sdk/WebKit/decoder.mm       |   1 -
 .../Common/RTCUIApplicationStatusObserver.h   |   1 +
 .../VideoToolbox/RTCVideoEncoderH264.mm       | 235 +++++++++++++-----
 .../Headers/WebRTC/RTCAudioSession.h          |   4 +
 .../WebRTC/RTCAudioSessionConfiguration.h     |   1 +
 .../Framework/Headers/WebRTC/RTCAudioSource.h |   1 +
 .../Framework/Headers/WebRTC/RTCAudioTrack.h  |   1 +
 .../Headers/WebRTC/RTCCameraPreviewView.h     |   1 +
 .../Headers/WebRTC/RTCConfiguration.h         |   1 +
 .../Framework/Headers/WebRTC/RTCDataChannel.h |   2 +
 .../WebRTC/RTCDataChannelConfiguration.h      |   1 +
 .../Framework/Headers/WebRTC/RTCDispatcher.h  |   1 +
 .../Framework/Headers/WebRTC/RTCFileLogger.h  |   1 +
 .../Headers/WebRTC/RTCIceCandidate.h          |   1 +
 .../Framework/Headers/WebRTC/RTCIceServer.h   |   1 +
 .../Headers/WebRTC/RTCIntervalRange.h         |   1 +
 .../Headers/WebRTC/RTCLegacyStatsReport.h     |   1 +
 .../Headers/WebRTC/RTCMediaConstraints.h      |   1 +
 .../Framework/Headers/WebRTC/RTCMediaSource.h |   1 +
 .../Framework/Headers/WebRTC/RTCMediaStream.h |   1 +
 .../Headers/WebRTC/RTCMediaStreamTrack.h      |   1 +
 .../Headers/WebRTC/RTCMetricsSampleInfo.h     |   1 +
 .../Headers/WebRTC/RTCPeerConnection.h        |   4 +
 .../Headers/WebRTC/RTCPeerConnectionFactory.h |   1 +
 .../Headers/WebRTC/RTCRtpCodecParameters.h    |   1 +
 .../Headers/WebRTC/RTCRtpEncodingParameters.h |   1 +
 .../Headers/WebRTC/RTCRtpParameters.h         |   1 +
 .../Framework/Headers/WebRTC/RTCRtpReceiver.h |   1 +
 .../Framework/Headers/WebRTC/RTCRtpSender.h   |   1 +
 .../Headers/WebRTC/RTCSessionDescription.h    |   1 +
 .../Headers/WebRTC/RTCVideoCapturer.h         |   1 +
 .../Framework/Headers/WebRTC/RTCVideoCodec.h  |   5 +
 .../Headers/WebRTC/RTCVideoCodecFactory.h     |   2 +
 .../Headers/WebRTC/RTCVideoCodecH264.h        |   6 +
 .../Headers/WebRTC/RTCVideoDecoderVP8.h       |   1 +
 .../Headers/WebRTC/RTCVideoDecoderVP9.h       |   1 +
 .../Headers/WebRTC/RTCVideoEncoderVP8.h       |   1 +
 .../Headers/WebRTC/RTCVideoEncoderVP9.h       |   1 +
 .../Framework/Headers/WebRTC/RTCVideoFrame.h  |   1 +
 .../Headers/WebRTC/RTCVideoFrameBuffer.h      |   3 +
 .../Framework/Headers/WebRTC/RTCVideoSource.h |   1 +
 .../Framework/Headers/WebRTC/RTCVideoTrack.h  |   1 +
 73 files changed, 307 insertions(+), 118 deletions(-)

diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/api/audio_codecs/ilbc/audio_encoder_ilbc.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/api/audio_codecs/ilbc/audio_encoder_ilbc.cc
index efcef382ff7..2ae75474ccd 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/api/audio_codecs/ilbc/audio_encoder_ilbc.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/api/audio_codecs/ilbc/audio_encoder_ilbc.cc
@@ -33,7 +33,7 @@ int GetIlbcBitrate(int ptime) {
       // 50 bytes per frame of 30 ms => (approx) 13333 bits/s.
       return 13333;
     default:
-      FATAL();
+      RTC_FATAL();
   }
 }
 }  // namespace
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/api/mediatypes.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/api/mediatypes.cc
index 599542db08f..140d0ae9625 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/api/mediatypes.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/api/mediatypes.cc
@@ -28,7 +28,7 @@ std::string MediaTypeToString(MediaType type) {
     case MEDIA_TYPE_DATA:
       return kMediaTypeData;
   }
-  FATAL();
+  RTC_FATAL();
   // Not reachable; avoids compile warning.
   return "";
 }
@@ -41,7 +41,7 @@ MediaType MediaTypeFromString(const std::string& type_str) {
   } else if (type_str == kMediaTypeData) {
     return MEDIA_TYPE_DATA;
   }
-  FATAL();
+  RTC_FATAL();
   // Not reachable; avoids compile warning.
   return static_cast<MediaType>(-1);
 }
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/audio/remix_resample.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/audio/remix_resample.cc
index eda70c7c378..97222e947a4 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/audio/remix_resample.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/audio/remix_resample.cc
@@ -58,7 +58,7 @@ void RemixAndResample(const int16_t* src_data,
 
   if (resampler->InitializeIfNeeded(sample_rate_hz, dst_frame->sample_rate_hz_,
                                     audio_ptr_num_channels) == -1) {
-    FATAL() << "InitializeIfNeeded failed: sample_rate_hz = " << sample_rate_hz
+    RTC_FATAL() << "InitializeIfNeeded failed: sample_rate_hz = " << sample_rate_hz
             << ", dst_frame->sample_rate_hz_ = " << dst_frame->sample_rate_hz_
             << ", audio_ptr_num_channels = " << audio_ptr_num_channels;
   }
@@ -72,7 +72,7 @@ void RemixAndResample(const int16_t* src_data,
       resampler->Resample(audio_ptr, src_length, dst_frame->mutable_data(),
                           AudioFrame::kMaxDataSizeSamples);
   if (out_length == -1) {
-    FATAL() << "Resample failed: audio_ptr = " << audio_ptr
+    RTC_FATAL() << "Resample failed: audio_ptr = " << audio_ptr
             << ", src_length = " << src_length
             << ", dst_frame->mutable_data() = " << dst_frame->mutable_data();
   }
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/common_audio/wav_file.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/common_audio/wav_file.cc
index 008891f9cfb..0209f52d2c7 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/common_audio/wav_file.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/common_audio/wav_file.cc
@@ -53,7 +53,7 @@ WavReader::WavReader(rtc::PlatformFile file) {
     if (!rtc::ClosePlatformFile(file)) {
       RTC_LOG(LS_ERROR) << "Can't close file.";
     }
-    FATAL() << "Could not open wav file for reading.";
+    RTC_FATAL() << "Could not open wav file for reading.";
   }
 
   ReadableWavFile readable(file_handle_);
@@ -138,7 +138,7 @@ WavWriter::WavWriter(rtc::PlatformFile file,
     if (!rtc::ClosePlatformFile(file)) {
       RTC_LOG(LS_ERROR) << "Can't close file.";
     }
-    FATAL() << "Could not open wav file for writing.";
+    RTC_FATAL() << "Could not open wav file for writing.";
   }
 
   RTC_CHECK(CheckWavParameters(num_channels_, sample_rate_, kWavFormat,
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/common_video/video_frame_buffer.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/common_video/video_frame_buffer.cc
index 2cd0b290f15..be0b4927bbe 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/common_video/video_frame_buffer.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/common_video/video_frame_buffer.cc
@@ -323,7 +323,7 @@ rtc::scoped_refptr<PlanarYuvBuffer> WrapYuvBuffer(
       return WrapI444Buffer(width, height, y_plane, y_stride, u_plane, u_stride,
                             v_plane, v_stride, no_longer_used);
     default:
-      FATAL() << "Unexpected frame buffer type.";
+      RTC_FATAL() << "Unexpected frame buffer type.";
       return nullptr;
   }
 }
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/media/base/codec.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/media/base/codec.cc
index caf32121125..ee7eda343b3 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/media/base/codec.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/media/base/codec.cc
@@ -271,8 +271,10 @@ bool VideoCodec::Matches(const VideoCodec& other) const {
   if (CodecNamesEq(name.c_str(), kH264CodecName))
     return webrtc::H264::IsSameH264Profile(params, other.params) &&
            IsSameH264PacketizationMode(params, other.params);
+#if !defined(RTC_DISABLE_VP9)
   if (CodecNamesEq(name.c_str(), kVp9CodecName))
     return webrtc::IsSameVP9Profile(params, other.params);
+#endif
   return true;
 }
 
@@ -392,8 +394,10 @@ bool IsSameCodec(const std::string& name1,
   // For every format besides H264 and VP9, comparing names is enough.
   if (CodecNamesEq(name1.c_str(), kH264CodecName))
     return webrtc::H264::IsSameH264Profile(params1, params2);
+#if !defined(RTC_DISABLE_VP9)
   if (CodecNamesEq(name1.c_str(), kVp9CodecName))
     return webrtc::IsSameVP9Profile(params1, params2);
+#endif
   return true;
 }
 
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/acm2/audio_coding_module.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/acm2/audio_coding_module.cc
index 7f652a215d6..ef4250eb40e 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/acm2/audio_coding_module.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/acm2/audio_coding_module.cc
@@ -1149,7 +1149,7 @@ int AudioCodingModuleImpl::SetOpusApplication(OpusApplicationMode application) {
       app = AudioEncoder::Application::kAudio;
       break;
     default:
-      FATAL();
+      RTC_FATAL();
       return 0;
   }
   return encoder_stack_->SetApplication(app) ? 0 : -1;
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/acm2/rent_a_codec.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/acm2/rent_a_codec.cc
index 818e17f3b57..7eff320b723 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/acm2/rent_a_codec.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/acm2/rent_a_codec.cc
@@ -215,7 +215,7 @@ std::unique_ptr<AudioEncoder> CreateCngEncoder(
       config.vad_mode = Vad::kVadVeryAggressive;
       break;
     default:
-      FATAL();
+      RTC_FATAL();
   }
   return std::unique_ptr<AudioEncoder>(new AudioEncoderCng(std::move(config)));
 }
@@ -230,7 +230,7 @@ std::unique_ptr<AudioDecoder> CreateIsacDecoder(
   return std::unique_ptr<AudioDecoder>(
       new AudioDecoderIsacFloatImpl(sample_rate_hz, bwinfo));
 #else
-  FATAL() << "iSAC is not supported.";
+  RTC_FATAL() << "iSAC is not supported.";
   return std::unique_ptr<AudioDecoder>();
 #endif
 }
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/codecs/cng/audio_encoder_cng.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/codecs/cng/audio_encoder_cng.cc
index 4cda3401fa2..055190497a5 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/codecs/cng/audio_encoder_cng.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/codecs/cng/audio_encoder_cng.cc
@@ -139,7 +139,7 @@ AudioEncoder::EncodedInfo AudioEncoderCng::EncodeImpl(
       break;
     }
     case Vad::kError: {
-      FATAL();  // Fails only if fed invalid data.
+      RTC_FATAL();  // Fails only if fed invalid data.
       break;
     }
   }
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/codecs/ilbc/audio_encoder_ilbc.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/codecs/ilbc/audio_encoder_ilbc.cc
index 84695e37630..dae956b30c0 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/codecs/ilbc/audio_encoder_ilbc.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/codecs/ilbc/audio_encoder_ilbc.cc
@@ -40,7 +40,7 @@ int GetIlbcBitrate(int ptime) {
       // 50 bytes per frame of 30 ms => (approx) 13333 bits/s.
       return 13333;
     default:
-      FATAL();
+      RTC_FATAL();
   }
 }
 
@@ -147,7 +147,7 @@ size_t AudioEncoderIlbcImpl::RequiredOutputSizeBytes() const {
     case 6:
       return 2 * 50;
     default:
-      FATAL();
+      RTC_FATAL();
   }
 }
 
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/neteq/tools/rtp_file_source.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/neteq/tools/rtp_file_source.cc
index 806bba7a9fe..7bf7d52083c 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/neteq/tools/rtp_file_source.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/neteq/tools/rtp_file_source.cc
@@ -89,7 +89,7 @@ bool RtpFileSource::OpenFile(const std::string& file_name) {
     return true;
   rtp_reader_.reset(RtpFileReader::Create(RtpFileReader::kPcap, file_name));
   if (!rtp_reader_) {
-    FATAL() << "Couldn't open input file as either a rtpdump or .pcap. Note "
+    RTC_FATAL() << "Couldn't open input file as either a rtpdump or .pcap. Note "
                "that .pcapng is not supported.";
   }
   return true;
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/codecs/vp8/include/vp8.h b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/codecs/vp8/include/vp8.h
index 57be521320d..580755f08de 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/codecs/vp8/include/vp8.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/codecs/vp8/include/vp8.h
@@ -22,6 +22,7 @@ namespace webrtc {
 class VP8Encoder : public VideoEncoder {
  public:
   static std::unique_ptr<VP8Encoder> Create();
+  static bool IsSupported();
 
   ~VP8Encoder() override {}
 };  // end of VP8Encoder class
@@ -29,6 +30,7 @@ class VP8Encoder : public VideoEncoder {
 class VP8Decoder : public VideoDecoder {
  public:
   static std::unique_ptr<VP8Decoder> Create();
+  static bool IsSupported();
 
   ~VP8Decoder() override {}
 };  // end of VP8Decoder class
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/qp_parser.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/qp_parser.cc
index 2adbca9b712..2db0d9cbf53 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/qp_parser.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/qp_parser.cc
@@ -21,9 +21,11 @@ bool QpParser::GetQp(const VCMEncodedFrame& frame, int* qp) {
     case kVideoCodecVP8:
       // QP range: [0, 127].
       return vp8::GetQp(frame.Buffer(), frame.Length(), qp);
+#if !defined(RTC_DISABLE_VP9)
     case kVideoCodecVP9:
       // QP range: [0, 255].
       return vp9::GetQp(frame.Buffer(), frame.Length(), qp);
+#endif
     default:
       return false;
   }
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/video_codec_initializer.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/video_codec_initializer.cc
index fe59afc184c..cd73551891a 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/video_codec_initializer.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/video_coding/video_codec_initializer.cc
@@ -56,9 +56,11 @@ VideoCodecInitializer::CreateBitrateAllocator(const VideoCodec& codec) {
     case kVideoCodecH264:
       rate_allocator.reset(new SimulcastRateAllocator(codec));
       break;
+#if !defined(RTC_DISABLE_VP9)
     case kVideoCodecVP9:
       rate_allocator.reset(new SvcRateAllocator(codec));
       break;
+#endif
     default:
       rate_allocator.reset(new DefaultVideoBitrateAllocator(codec));
   }
@@ -177,6 +179,7 @@ VideoCodec VideoCodecInitializer::VideoEncoderConfigToVideoCodec(
 
       break;
     }
+#if !defined(RTC_DISABLE_VP9)
     case kVideoCodecVP9: {
       if (!config.encoder_specific_settings) {
         *video_codec.VP9() = VideoEncoder::GetDefaultVp9Settings();
@@ -232,6 +235,7 @@ VideoCodec VideoCodecInitializer::VideoEncoderConfigToVideoCodec(
 
       break;
     }
+#endif
     case kVideoCodecH264: {
       if (!config.encoder_specific_settings)
         *video_codec.H264() = VideoEncoder::GetDefaultH264Settings();
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/pc/peerconnectionfactory.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/pc/peerconnectionfactory.cc
index d407228e67c..a6db5198692 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/pc/peerconnectionfactory.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/pc/peerconnectionfactory.cc
@@ -257,7 +257,7 @@ RtpCapabilities PeerConnectionFactory::GetRtpSenderCapabilities(
       return RtpCapabilities();
   }
   // Not reached; avoids compile warning.
-  FATAL();
+  RTC_FATAL();
 }
 
 RtpCapabilities PeerConnectionFactory::GetRtpReceiverCapabilities(
@@ -284,7 +284,7 @@ RtpCapabilities PeerConnectionFactory::GetRtpReceiverCapabilities(
       return RtpCapabilities();
   }
   // Not reached; avoids compile warning.
-  FATAL();
+  RTC_FATAL();
 }
 
 rtc::scoped_refptr<AudioSourceInterface>
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/pc/rtpparametersconversion.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/pc/rtpparametersconversion.cc
index a57066e4db0..e519b9b06de 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/pc/rtpparametersconversion.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/pc/rtpparametersconversion.cc
@@ -61,7 +61,7 @@ RTCErrorOr<cricket::FeedbackParam> ToCricketFeedbackParam(
       return cricket::FeedbackParam(cricket::kRtcpFbParamTransportCc);
   }
   // Not reached; avoids compile warning.
-  FATAL();
+  RTC_FATAL();
 }
 
 template <typename C>
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/checks.h b/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/checks.h
index a65088d3fda..c7cf36e4b4d 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/checks.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/checks.h
@@ -81,7 +81,7 @@ RTC_NORETURN void rtc_FatalMessage(const char* file, int line, const char* msg);
 //   messages if the condition doesn't hold. Prefer them to raw RTC_CHECK and
 //   RTC_DCHECK.
 //
-// - FATAL() aborts unconditionally.
+// - RTC_FATAL() aborts unconditionally.
 //
 // TODO(ajm): Ideally, checks.h would be combined with logging.h, but
 // consolidation with system_wrappers/logging.h should happen first.
@@ -349,7 +349,7 @@ class FatalLogCall final {
 #define RTC_NOTREACHED() RTC_DCHECK(RTC_UNREACHABLE_CODE_HIT)
 
 // TODO(bugs.webrtc.org/8454): Add an RTC_ prefix or rename differently.
-#define FATAL()                                                    \
+#define RTC_FATAL()                                                    \
   rtc::webrtc_checks_impl::FatalLogCall<false>(__FILE__, __LINE__, \
                                                "FATAL()") &        \
       rtc::webrtc_checks_impl::LogStreamer<>()
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/flags.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/flags.cc
index 5b28794f6ca..4f294594bd4 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/flags.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/flags.cc
@@ -80,7 +80,7 @@ void Flag::SetToDefault() {
       variable_->s = default_.s;
       return;
   }
-  FATAL() << "unreachable code";
+  RTC_FATAL() << "unreachable code";
 }
 
 static const char* Type2String(Flag::Type type) {
@@ -94,7 +94,7 @@ static const char* Type2String(Flag::Type type) {
     case Flag::STRING:
       return "string";
   }
-  FATAL() << "unreachable code";
+  RTC_FATAL() << "unreachable code";
 }
 
 static void PrintFlagValue(Flag::Type type, FlagValue* p) {
@@ -112,7 +112,7 @@ static void PrintFlagValue(Flag::Type type, FlagValue* p) {
       printf("%s", p->s);
       return;
   }
-  FATAL() << "unreachable code";
+  RTC_FATAL() << "unreachable code";
 }
 
 void Flag::Print(bool print_current_value) {
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/location.h b/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/location.h
index 513bc263651..718d9589348 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/location.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/location.h
@@ -50,7 +50,7 @@ class Location {
 #define RTC_FROM_HERE RTC_FROM_HERE_WITH_FUNCTION(__FUNCTION__)
 
 #define RTC_FROM_HERE_WITH_FUNCTION(function_name) \
-  ::rtc::Location(function_name, __FILE__ ":" STRINGIZE(__LINE__))
+  ::rtc::Location(function_name, __FILE__ ":" RTC_STRINGIZE(__LINE__))
 
 }  // namespace rtc
 
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/logging_unittest.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/logging_unittest.cc
index af512129fbb..7c411926440 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/logging_unittest.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/logging_unittest.cc
@@ -196,7 +196,7 @@ TEST(LogTest, SingleStream) {
 
 #if GTEST_HAS_DEATH_TEST && !defined(WEBRTC_ANDROID)
 TEST(LogTest, Checks) {
-  EXPECT_DEATH(FATAL() << "message",
+  EXPECT_DEATH(RTC_FATAL() << "message",
                "\n\n#\n"
                "# Fatal error in: \\S+, line \\w+\n"
                "# last system error: \\w+\n"
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/numerics/safe_conversions.h b/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/numerics/safe_conversions.h
index 58efcaa746a..48c212e4d49 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/numerics/safe_conversions.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/numerics/safe_conversions.h
@@ -63,11 +63,11 @@ inline Dst saturated_cast(Src value) {
 
     // Should fail only on attempting to assign NaN to a saturated integer.
     case internal::TYPE_INVALID:
-      FATAL();
+      RTC_FATAL();
       return std::numeric_limits<Dst>::max();
   }
 
-  FATAL();
+  RTC_FATAL();
   return static_cast<Dst>(value);
 }
 
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/opensslcertificate.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/opensslcertificate.cc
index ed67a8938e1..236bef55c8a 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/opensslcertificate.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/opensslcertificate.cc
@@ -256,11 +256,11 @@ OpenSSLCertificate* OpenSSLCertificate::GetReference() const {
 std::string OpenSSLCertificate::ToPEMString() const {
   BIO* bio = BIO_new(BIO_s_mem());
   if (!bio) {
-    FATAL() << "unreachable code";
+    RTC_FATAL() << "unreachable code";
   }
   if (!PEM_write_bio_X509(bio, x509_)) {
     BIO_free(bio);
-    FATAL() << "unreachable code";
+    RTC_FATAL() << "unreachable code";
   }
   BIO_write(bio, "\0", 1);
   char* buffer;
@@ -277,11 +277,11 @@ void OpenSSLCertificate::ToDER(Buffer* der_buffer) const {
   // Calculates the DER representation of the certificate, from scratch.
   BIO* bio = BIO_new(BIO_s_mem());
   if (!bio) {
-    FATAL() << "unreachable code";
+    RTC_FATAL() << "unreachable code";
   }
   if (!i2d_X509_bio(bio, x509_)) {
     BIO_free(bio);
-    FATAL() << "unreachable code";
+    RTC_FATAL() << "unreachable code";
   }
   char* data;
   size_t length = BIO_get_mem_data(bio, &data);
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/physicalsocketserver.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/physicalsocketserver.cc
index ca78499179a..0e9a17a6af5 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/physicalsocketserver.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/physicalsocketserver.cc
@@ -605,7 +605,7 @@ bool SocketDispatcher::Initialize() {
 #elif defined(WEBRTC_POSIX)
   fcntl(s_, F_SETFL, fcntl(s_, F_GETFL, 0) | O_NONBLOCK);
 #endif
-#if defined(WEBRTC_IOS)
+#if defined(WEBRTC_IOS) || (defined(WEBRTC_MAC) && defined(WEBRTC_WEBKIT_BUILD))
   // iOS may kill sockets when the app is moved to the background
   // (specifically, if the app doesn't use the "voip" UIBackgroundMode). When
   // we attempt to write to such a socket, SIGPIPE will be raised, which by
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/stringize_macros.h b/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/stringize_macros.h
index aee8d14551d..c94a90de1ba 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/stringize_macros.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/stringize_macros.h
@@ -21,7 +21,7 @@
 // This is not very useful as it does not expand defined symbols if
 // called directly. Use its counterpart without the _NO_EXPANSION
 // suffix, below.
-#define STRINGIZE_NO_EXPANSION(x) #x
+#define RTC_STRINGIZE_NO_EXPANSION(x) #x
 
 // Use this to quote the provided parameter, first expanding it if it
 // is a preprocessor symbol.
@@ -33,6 +33,6 @@
 // Then:
 //   STRINGIZE(A) produces "FOO"
 //   STRINGIZE(B(y)) produces "myobj->FunctionCall(y)"
-#define STRINGIZE(x) STRINGIZE_NO_EXPANSION(x)
+#define RTC_STRINGIZE(x) RTC_STRINGIZE_NO_EXPANSION(x)
 
 #endif  // RTC_BASE_STRINGIZE_MACROS_H_
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/task_queue_gcd.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/task_queue_gcd.cc
index c7731dda3ee..f7ba4d1db80 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/task_queue_gcd.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/task_queue_gcd.cc
@@ -139,7 +139,7 @@ class TaskQueue::Impl : public RefCountInterface {
 TaskQueue::Impl::Impl(const char* queue_name,
                       TaskQueue* task_queue,
                       Priority priority)
-    : queue_(dispatch_queue_create(queue_name, DISPATCH_QUEUE_SERIAL)),
+    : queue_(dispatch_queue_create_with_target(queue_name, DISPATCH_QUEUE_SERIAL, dispatch_get_global_queue(TaskQueuePriorityToGCD(priority), 0))),
       context_(new QueueContext(task_queue)) {
   RTC_DCHECK(queue_name);
   RTC_CHECK(queue_);
@@ -148,9 +148,6 @@ TaskQueue::Impl::Impl(const char* queue_name,
   // to the queue is released.  This may run after the TaskQueue object has
   // been deleted.
   dispatch_set_finalizer_f(queue_, &QueueContext::DeleteContext);
-
-  dispatch_set_target_queue(
-      queue_, dispatch_get_global_queue(TaskQueuePriorityToGCD(priority), 0));
 }
 
 TaskQueue::Impl::~Impl() {
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/WebKit/VideoProcessingSoftLink.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/WebKit/VideoProcessingSoftLink.h
index 4e5019dd4d8..cfa9dd6da96 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/WebKit/VideoProcessingSoftLink.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/WebKit/VideoProcessingSoftLink.h
@@ -38,7 +38,7 @@
 #elif (defined(TARGET_OS_IPHONE)  && TARGET_OS_IPHONE)
 #define ENABLE_VCP_ENCODER 0
 #elif (defined(TARGET_OS_MAC)  && TARGET_OS_MAC)
-#define ENABLE_VCP_ENCODER (__MAC_OS_X_VERSION_MAX_ALLOWED >= 101304)
+#define ENABLE_VCP_ENCODER 0 //(__MAC_OS_X_VERSION_MAX_ALLOWED >= 101304)
 #endif
 
 #endif
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/WebKit/VideoToolBoxDecoderFactory.cpp b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/WebKit/VideoToolBoxDecoderFactory.cpp
index 37de8f50070..e7307700080 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/WebKit/VideoToolBoxDecoderFactory.cpp
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/WebKit/VideoToolBoxDecoderFactory.cpp
@@ -69,7 +69,7 @@ std::unique_ptr<VideoDecoder> VideoToolboxVideoDecoderFactory::CreateVideoDecode
 }
 
 static inline SdpVideoFormat CreateH264Format(H264::Profile profile, H264::Level level) {
-    const rtc::Optional<std::string> profile_string =
+    const absl::optional<std::string> profile_string =
     H264::ProfileLevelIdToString(H264::ProfileLevelId(profile, level));
     RTC_CHECK(profile_string);
     return SdpVideoFormat(cricket::kH264CodecName,
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/WebKit/VideoToolBoxEncoderFactory.cpp b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/WebKit/VideoToolBoxEncoderFactory.cpp
index f45ff01780d..296703f35e0 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/WebKit/VideoToolBoxEncoderFactory.cpp
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/WebKit/VideoToolBoxEncoderFactory.cpp
@@ -69,8 +69,7 @@ void VideoToolboxVideoEncoderFactory::setH264HardwareEncoderAllowed(bool allowed
 }
 
 static inline SdpVideoFormat CreateH264Format(H264::Profile profile, H264::Level level) {
-    const rtc::Optional<std::string> profile_string =
-    H264::ProfileLevelIdToString(H264::ProfileLevelId(profile, level));
+    const absl::optional<std::string> profile_string = H264::ProfileLevelIdToString(H264::ProfileLevelId(profile, level));
     RTC_CHECK(profile_string);
     return SdpVideoFormat(cricket::kH264CodecName,
                           {{cricket::kH264FmtpProfileLevelId, *profile_string},
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/WebKit/WebKitUtilities.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/WebKit/WebKitUtilities.h
index 776da18fbc1..1ad27c85260 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/WebKit/WebKitUtilities.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/WebKit/WebKitUtilities.h
@@ -25,9 +25,10 @@
 
 #pragma once
 
-#include "api/video_codecs/video_encoder_factory.h"
 #include "api/video/video_frame_buffer.h"
 #include "rtc_base/scoped_ref_ptr.h"
+#include "webrtc/media/engine/webrtcvideodecoderfactory.h"
+#include "webrtc/media/engine/webrtcvideoencoderfactory.h"
 
 typedef struct __CVBuffer* CVPixelBufferRef;
 
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/WebKit/WebKitUtilities.mm b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/WebKit/WebKitUtilities.mm
index 5e65230f321..240a174534d 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/WebKit/WebKitUtilities.mm
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/WebKit/WebKitUtilities.mm
@@ -24,13 +24,17 @@
  */
 
 #include "WebKitUtilities.h"
+
 #include "Common/RTCUIApplicationStatusObserver.h"
-#include "VideoToolbox/objc_video_decoder_factory.h"
-#include "VideoToolbox/objc_video_encoder_factory.h"
 #import "WebRTC/RTCVideoCodecH264.h"
+
 #include "api/video/video_frame.h"
-#include <webrtc/sdk/objc/Framework/Classes/Video/objc_frame_buffer.h>
-#include <webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoFrameBuffer.h>
+#include "webrtc/sdk/objc/Framework/Native/src/objc_frame_buffer.h"
+#include "webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoFrame.h"
+#include "webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoFrameBuffer.h"
+#include "webrtc/sdk/objc/Framework/Native/api/video_decoder_factory.h"
+#include "webrtc/sdk/objc/Framework/Native/api/video_encoder_factory.h"
+
 
 #if !defined(WEBRTC_IOS)
 __attribute__((objc_runtime_name("WK_RTCUIApplicationStatusObserver")))
@@ -99,12 +103,12 @@ std::unique_ptr<webrtc::VideoEncoderFactory> createVideoToolboxEncoderFactory()
         webrtc::VPModuleInitialize();
     });
 #endif
-    return std::make_unique<webrtc::ObjCVideoEncoderFactory>([[RTCVideoEncoderFactoryH264 alloc] init]);
+    return ObjCToNativeVideoEncoderFactory([[RTCVideoEncoderFactoryH264 alloc] init]);
 }
 
 std::unique_ptr<webrtc::VideoDecoderFactory> createVideoToolboxDecoderFactory()
 {
-    return std::make_unique<webrtc::ObjCVideoDecoderFactory>([[RTCVideoDecoderFactoryH264 alloc] init]);
+    return ObjCToNativeVideoDecoderFactory([[RTCVideoDecoderFactoryH264 alloc] init]);
 }
 
 static bool h264HardwareEncoderAllowed = true;
@@ -120,17 +124,21 @@ bool isH264HardwareEncoderAllowed()
 
 rtc::scoped_refptr<webrtc::VideoFrameBuffer> pixelBufferToFrame(CVPixelBufferRef pixelBuffer)
 {
-    RTCCVPixelBuffer *frameBuffer = [[RTCCVPixelBuffer alloc] initWithPixelBuffer: pixelBuffer];
-    return new rtc::RefCountedObject<webrtc::ObjCFrameBuffer>(frameBuffer);
+    RTCCVPixelBuffer *frameBuffer = [[RTCCVPixelBuffer alloc] initWithPixelBuffer:pixelBuffer];
+    return new rtc::RefCountedObject<ObjCFrameBuffer>(frameBuffer);
 }
 
 CVPixelBufferRef pixelBufferFromFrame(const VideoFrame& frame)
 {
-    auto buffer = frame.video_frame_buffer();
-    auto frameBuffer = static_cast<webrtc::ObjCFrameBuffer&>(*buffer).wrapped_frame_buffer();
-    if ([frameBuffer isKindOfClass: [RTCCVPixelBuffer class]])
-        return [(RTCCVPixelBuffer *)frameBuffer pixelBuffer];
-    return nullptr;
+    if (frame.video_frame_buffer()->type() != VideoFrameBuffer::Type::kNative)
+        return nullptr;
+
+    auto *frameBuffer = static_cast<ObjCFrameBuffer*>(frame.video_frame_buffer().get())->wrapped_frame_buffer();
+    if (![frameBuffer isKindOfClass:[RTCCVPixelBuffer class]])
+        return nullptr;
+
+    auto *rtcPixelBuffer = (RTCCVPixelBuffer *)frameBuffer;
+    return rtcPixelBuffer.pixelBuffer;
 }
 
 }
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/WebKit/decoder.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/WebKit/decoder.h
index e0a7b03ef22..75b57dad79c 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/WebKit/decoder.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/WebKit/decoder.h
@@ -37,7 +37,6 @@ class H264VideoToolboxDecoder : public H264Decoder {
 
   int Decode(const EncodedImage& input_image,
              bool missing_frames,
-             const RTPFragmentationHeader* fragmentation,
              const CodecSpecificInfo* codec_specific_info,
              int64_t render_time_ms) override;
 
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/WebKit/decoder.mm b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/WebKit/decoder.mm
index 664a99aae56..ca4586bb7b5 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/WebKit/decoder.mm
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/WebKit/decoder.mm
@@ -99,7 +99,6 @@ int H264VideoToolboxDecoder::InitDecode(const VideoCodec* video_codec,
 int H264VideoToolboxDecoder::Decode(
     const EncodedImage& input_image,
     bool missing_frames,
-    const RTPFragmentationHeader* fragmentation,
     const CodecSpecificInfo* codec_specific_info,
     int64_t render_time_ms) {
   RTC_DCHECK(input_image._buffer);
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Classes/Common/RTCUIApplicationStatusObserver.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Classes/Common/RTCUIApplicationStatusObserver.h
index 0c032953be3..c7172288033 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Classes/Common/RTCUIApplicationStatusObserver.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Classes/Common/RTCUIApplicationStatusObserver.h
@@ -12,6 +12,7 @@
 
 #import <Foundation/Foundation.h>
 
+__attribute__((objc_runtime_name("WK_RTCUIApplicationStatusObserver")))
 NS_EXTENSION_UNAVAILABLE_IOS("Application status not available in app extensions.")
 @interface RTCUIApplicationStatusObserver : NSObject
 
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Classes/VideoToolbox/RTCVideoEncoderH264.mm b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Classes/VideoToolbox/RTCVideoEncoderH264.mm
index c167e54757d..d47818f763f 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Classes/VideoToolbox/RTCVideoEncoderH264.mm
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Classes/VideoToolbox/RTCVideoEncoderH264.mm
@@ -32,8 +32,46 @@
 #include "rtc_base/logging.h"
 #include "rtc_base/timeutils.h"
 #include "sdk/objc/Framework/Classes/VideoToolbox/nalu_rewriter.h"
+#include "system_wrappers/include/clock.h"
 #include "third_party/libyuv/include/libyuv/convert_from.h"
 
+#include "sdk/WebKit/EncoderUtilities.h"
+#include "sdk/WebKit/WebKitUtilities.h"
+
+#import <dlfcn.h>
+#import <objc/runtime.h>
+
+SOFT_LINK_FRAMEWORK_OPTIONAL(VideoToolBox)
+SOFT_LINK_POINTER_OPTIONAL(VideoToolBox, kVTVideoEncoderSpecification_Usage, NSString *)
+
+#if !ENABLE_VCP_ENCODER && !defined(WEBRTC_IOS)
+static inline bool isStandardFrameSize(int32_t width, int32_t height)
+{
+    // FIXME: Envision relaxing this rule, something like width and height dividable by 4 or 8 should be good enough.
+    if (width == 1280)
+        return height == 720;
+    if (width == 720)
+        return height == 1280;
+    if (width == 960)
+        return height == 540;
+    if (width == 540)
+        return height == 960;
+    if (width == 640)
+        return height == 480;
+    if (width == 480)
+        return height == 640;
+    if (width == 288)
+        return height == 352;
+    if (width == 352)
+        return height == 288;
+    if (width == 320)
+        return height == 240;
+    if (width == 240)
+        return height == 320;
+    return false;
+}
+#endif
+
 @interface RTCVideoEncoderH264 ()
 
 - (void)frameWasEncoded:(OSStatus)status
@@ -167,8 +205,8 @@ void compressionOutputCallback(void *encoder,
                                 rotation:encodeParams->rotation];
 }
 
-// Extract VideoToolbox profile out of the webrtc::SdpVideoFormat. If there is
-// no specific VideoToolbox profile for the specified level, AutoLevel will be
+// Extract VideoToolbox profile out of the cricket::VideoCodec. If there is no
+// specific VideoToolbox profile for the specified level, AutoLevel will be
 // returned. The user must initialize the encoder with a resolution and
 // framerate conforming to the selected H264 level regardless.
 CFStringRef ExtractProfile(webrtc::SdpVideoFormat videoFormat) {
@@ -284,8 +322,7 @@ @implementation RTCVideoEncoderH264 {
   RTCVideoEncoderCallback _callback;
   int32_t _width;
   int32_t _height;
-  VTCompressionSessionRef _compressionSession;
-  CVPixelBufferPoolRef _pixelBufferPool;
+  CompressionSessionRef _compressionSession;
   RTCVideoCodecMode _mode;
 
   webrtc::H264BitstreamParser _h264BitstreamParser;
@@ -308,7 +345,7 @@ - (instancetype)initWithCodecInfo:(RTCVideoCodecInfo *)codecInfo {
     RTC_LOG(LS_INFO) << "Using profile " << CFStringToString(_profile);
     RTC_CHECK([codecInfo.name isEqualToString:kRTCVideoCodecH264Name]);
 
-#if defined(WEBRTC_IOS) && !defined(RTC_APPRTCMOBILE_BROADCAST_EXTENSION)
+#if defined(WEBRTC_IOS)
     [RTCUIApplicationStatusObserver prepareForUse];
 #endif
   }
@@ -329,7 +366,7 @@ - (NSInteger)startEncodeWithSettings:(RTCVideoEncoderSettings *)settings
   _mode = settings.mode;
 
   // We can only set average bitrate on the HW encoder.
-  _targetBitrateBps = settings.startBitrate * 1000;  // startBitrate is in kbps.
+  _targetBitrateBps = settings.startBitrate;
   _bitrateAdjuster->SetTargetBitrateBps(_targetBitrateBps);
 
   // TODO(tkchin): Try setting payload size via
@@ -346,7 +383,7 @@ - (NSInteger)encode:(RTCVideoFrame *)frame
   if (!_callback || !_compressionSession) {
     return WEBRTC_VIDEO_CODEC_UNINITIALIZED;
   }
-#if defined(WEBRTC_IOS) && !defined(RTC_APPRTCMOBILE_BROADCAST_EXTENSION)
+#if defined(WEBRTC_IOS)
   if (![[RTCUIApplicationStatusObserver sharedInstance] isApplicationActive]) {
     // Ignore all encode requests when app isn't active. In this state, the
     // hardware encoder has been invalidated by the OS.
@@ -356,7 +393,10 @@ - (NSInteger)encode:(RTCVideoFrame *)frame
   BOOL isKeyframeRequired = NO;
 
   // Get a pixel buffer from the pool and copy frame data over.
-  if ([self resetCompressionSessionIfNeededWithFrame:frame]) {
+  CVPixelBufferPoolRef pixelBufferPool =
+      CompressionSessionGetPixelBufferPool(_compressionSession);
+  if ([self resetCompressionSessionIfNeededForPool:pixelBufferPool withFrame:frame]) {
+    pixelBufferPool = CompressionSessionGetPixelBufferPool(_compressionSession);
     isKeyframeRequired = YES;
   }
 
@@ -373,7 +413,7 @@ - (NSInteger)encode:(RTCVideoFrame *)frame
       CVBufferRetain(pixelBuffer);
     } else {
       // Cropping required, we need to crop and scale to a new pixel buffer.
-      pixelBuffer = CreatePixelBuffer(_pixelBufferPool);
+      pixelBuffer = CreatePixelBuffer(pixelBufferPool);
       if (!pixelBuffer) {
         return WEBRTC_VIDEO_CODEC_ERROR;
       }
@@ -396,7 +436,7 @@ - (NSInteger)encode:(RTCVideoFrame *)frame
 
   if (!pixelBuffer) {
     // We did not have a native frame buffer
-    pixelBuffer = CreatePixelBuffer(_pixelBufferPool);
+    pixelBuffer = CreatePixelBuffer(pixelBufferPool);
     if (!pixelBuffer) {
       return WEBRTC_VIDEO_CODEC_ERROR;
     }
@@ -439,7 +479,7 @@ - (NSInteger)encode:(RTCVideoFrame *)frame
   // Update the bitrate if needed.
   [self setBitrateBps:_bitrateAdjuster->GetAdjustedBitrateBps()];
 
-  OSStatus status = VTCompressionSessionEncodeFrame(_compressionSession,
+  OSStatus status = CompressionSessionEncodeFrame(_compressionSession,
                                                     pixelBuffer,
                                                     presentationTimeStamp,
                                                     kCMTimeInvalid,
@@ -452,14 +492,7 @@ - (NSInteger)encode:(RTCVideoFrame *)frame
   if (pixelBuffer) {
     CVBufferRelease(pixelBuffer);
   }
-
-  if (status == kVTInvalidSessionErr) {
-    // This error occurs when entering foreground after backgrounding the app.
-    RTC_LOG(LS_ERROR) << "Invalid compression session, resetting.";
-    [self resetCompressionSessionWithPixelFormat:[self pixelFormatOfFrame:frame]];
-
-    return WEBRTC_VIDEO_CODEC_NO_OUTPUT;
-  } else if (status != noErr) {
+  if (status != noErr) {
     RTC_LOG(LS_ERROR) << "Failed to encode frame with code: " << status;
     return WEBRTC_VIDEO_CODEC_ERROR;
   }
@@ -488,44 +521,51 @@ - (NSInteger)releaseEncoder {
   return WEBRTC_VIDEO_CODEC_OK;
 }
 
-- (OSType)pixelFormatOfFrame:(RTCVideoFrame *)frame {
-  // Use NV12 for non-native frames.
-  if ([frame.buffer isKindOfClass:[RTCCVPixelBuffer class]]) {
-    RTCCVPixelBuffer *rtcPixelBuffer = (RTCCVPixelBuffer *)frame.buffer;
-    return CVPixelBufferGetPixelFormatType(rtcPixelBuffer.pixelBuffer);
-  }
-
-  return kNV12PixelFormat;
-}
-
-- (BOOL)resetCompressionSessionIfNeededWithFrame:(RTCVideoFrame *)frame {
+- (BOOL)resetCompressionSessionIfNeededForPool:(CVPixelBufferPoolRef)pixelBufferPool
+                                     withFrame:(RTCVideoFrame *)frame {
   BOOL resetCompressionSession = NO;
 
+#if defined(WEBRTC_IOS)
+  if (!pixelBufferPool) {
+    // Kind of a hack. On backgrounding, the compression session seems to get
+    // invalidated, which causes this pool call to fail when the application
+    // is foregrounded and frames are being sent for encoding again.
+    // Resetting the session when this happens fixes the issue.
+    // In addition we request a keyframe so video can recover quickly.
+    resetCompressionSession = YES;
+    RTC_LOG(LS_INFO) << "Resetting compression session due to invalid pool.";
+  }
+#endif
+
   // If we're capturing native frames in another pixel format than the compression session is
   // configured with, make sure the compression session is reset using the correct pixel format.
-  OSType framePixelFormat = [self pixelFormatOfFrame:frame];
-
-  if (_compressionSession) {
+  // If we're capturing non-native frames and the compression session is configured with a non-NV12
+  // format, reset it to NV12.
+  OSType framePixelFormat = kNV12PixelFormat;
+  if (pixelBufferPool) {
     // The pool attribute `kCVPixelBufferPixelFormatTypeKey` can contain either an array of pixel
     // formats or a single pixel format.
     NSDictionary *poolAttributes =
-        (__bridge NSDictionary *)CVPixelBufferPoolGetPixelBufferAttributes(_pixelBufferPool);
+        (__bridge NSDictionary *)CVPixelBufferPoolGetPixelBufferAttributes(pixelBufferPool);
     id pixelFormats =
         [poolAttributes objectForKey:(__bridge NSString *)kCVPixelBufferPixelFormatTypeKey];
     NSArray<NSNumber *> *compressionSessionPixelFormats = nil;
     if ([pixelFormats isKindOfClass:[NSArray class]]) {
       compressionSessionPixelFormats = (NSArray *)pixelFormats;
-    } else if ([pixelFormats isKindOfClass:[NSNumber class]]) {
+    } else {
       compressionSessionPixelFormats = @[ (NSNumber *)pixelFormats ];
     }
 
+    if ([frame.buffer isKindOfClass:[RTCCVPixelBuffer class]]) {
+      RTCCVPixelBuffer *rtcPixelBuffer = (RTCCVPixelBuffer *)frame.buffer;
+      framePixelFormat = CVPixelBufferGetPixelFormatType(rtcPixelBuffer.pixelBuffer);
+    }
+
     if (![compressionSessionPixelFormats
             containsObject:[NSNumber numberWithLong:framePixelFormat]]) {
       resetCompressionSession = YES;
       RTC_LOG(LS_INFO) << "Resetting compression session due to non-matching pixel format.";
     }
-  } else {
-    resetCompressionSession = YES;
   }
 
   if (resetCompressionSession) {
@@ -562,22 +602,21 @@ - (int)resetCompressionSessionWithPixelFormat:(OSType)framePixelFormat {
     CFRelease(pixelFormat);
     pixelFormat = nullptr;
   }
-  CFMutableDictionaryRef encoder_specs = nullptr;
+  CFDictionaryRef encoderSpecs = nullptr;
 #if defined(WEBRTC_MAC) && !defined(WEBRTC_IOS)
+  auto useHardwareEncoder = webrtc::isH264HardwareEncoderAllowed() ? kCFBooleanTrue : kCFBooleanFalse;
   // Currently hw accl is supported above 360p on mac, below 360p
   // the compression session will be created with hw accl disabled.
-  encoder_specs = CFDictionaryCreateMutable(
-      nullptr, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
-  CFDictionarySetValue(encoder_specs,
-                       kVTVideoEncoderSpecification_EnableHardwareAcceleratedVideoEncoder,
-                       kCFBooleanTrue);
+  CFTypeRef sessionKeys[] = { kVTVideoEncoderSpecification_EnableHardwareAcceleratedVideoEncoder, kVTVideoEncoderSpecification_RequireHardwareAcceleratedVideoEncoder, kVTCompressionPropertyKey_RealTime };
+  CFTypeRef sessionValues[] = { useHardwareEncoder, useHardwareEncoder, kCFBooleanTrue };
+  encoderSpecs = CFDictionaryCreate(kCFAllocatorDefault, sessionKeys, sessionValues, 3, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
 #endif
   OSStatus status =
-      VTCompressionSessionCreate(nullptr,  // use default allocator
+      CompressionSessionCreate(nullptr,  // use default allocator
                                  _width,
                                  _height,
-                                 kCMVideoCodecType_H264,
-                                 encoder_specs,  // use hardware accelerated encoder if available
+                                 kCodecTypeH264,
+                                 encoderSpecs,  // use hardware accelerated encoder if available
                                  sourceAttributes,
                                  nullptr,  // use default compressed data allocator
                                  compressionOutputCallback,
@@ -587,32 +626,105 @@ - (int)resetCompressionSessionWithPixelFormat:(OSType)framePixelFormat {
     CFRelease(sourceAttributes);
     sourceAttributes = nullptr;
   }
-  if (encoder_specs) {
-    CFRelease(encoder_specs);
-    encoder_specs = nullptr;
+  if (encoderSpecs) {
+    CFRelease(encoderSpecs);
+    encoderSpecs = nullptr;
   }
+
+#if ENABLE_VCP_ENCODER || defined(WEBRTC_IOS)
   if (status != noErr) {
     RTC_LOG(LS_ERROR) << "Failed to create compression session: " << status;
     return WEBRTC_VIDEO_CODEC_ERROR;
   }
+#endif
 #if defined(WEBRTC_MAC) && !defined(WEBRTC_IOS)
   CFBooleanRef hwaccl_enabled = nullptr;
-  status = VTSessionCopyProperty(_compressionSession,
+  if (status == noErr) {
+    status = VTSessionCopyProperty(_compressionSession,
                                  kVTCompressionPropertyKey_UsingHardwareAcceleratedVideoEncoder,
                                  nullptr,
                                  &hwaccl_enabled);
+  }
   if (status == noErr && (CFBooleanGetValue(hwaccl_enabled))) {
     RTC_LOG(LS_INFO) << "Compression session created with hw accl enabled";
   } else {
     RTC_LOG(LS_INFO) << "Compression session created with hw accl disabled";
+
+#if !ENABLE_VCP_ENCODER && !defined(WEBRTC_IOS)
+    if (!isStandardFrameSize(_width, _height)) {
+      RTC_LOG(LS_ERROR) << "Using H264 software encoder with non standard size is not supported";
+      return WEBRTC_VIDEO_CODEC_ERROR;
+    }
+
+    if (!getkVTVideoEncoderSpecification_Usage()) {
+      RTC_LOG(LS_ERROR) << "RTCVideoEncoderH264 cannot create a H264 software encoder";
+      return WEBRTC_VIDEO_CODEC_ERROR;
+    }
+
+    CFDictionaryRef ioSurfaceValue = CreateCFTypeDictionary(nullptr, nullptr, 0);
+    int64_t pixelFormatType = framePixelFormat;
+    CFNumberRef pixelFormat = CFNumberCreate(nullptr, kCFNumberLongType, &pixelFormatType);
+
+    const size_t attributesSize = 3;
+    CFTypeRef keys[attributesSize] = {
+      kCVPixelBufferOpenGLCompatibilityKey,
+      kCVPixelBufferIOSurfacePropertiesKey,
+      kCVPixelBufferPixelFormatTypeKey
+    };
+    CFTypeRef values[attributesSize] = {
+      kCFBooleanTrue,
+      ioSurfaceValue,
+      pixelFormat};
+    CFDictionaryRef sourceAttributes = CreateCFTypeDictionary(keys, values, attributesSize);
+
+    if (ioSurfaceValue) {
+      CFRelease(ioSurfaceValue);
+      ioSurfaceValue = nullptr;
+    }
+    if (pixelFormat) {
+      CFRelease(pixelFormat);
+      pixelFormat = nullptr;
+    }
+
+    CFMutableDictionaryRef encoderSpecs = CFDictionaryCreateMutable(nullptr, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
+    CFDictionarySetValue(encoderSpecs, kVTVideoEncoderSpecification_EnableHardwareAcceleratedVideoEncoder, kCFBooleanFalse);
+    int usageValue = 1;
+    CFNumberRef usage = CFNumberCreate(nullptr, kCFNumberIntType, &usageValue);
+    CFDictionarySetValue(encoderSpecs, (__bridge CFStringRef)getkVTVideoEncoderSpecification_Usage(), usage);
+
+    if (usage) {
+      CFRelease(usage);
+      usage = nullptr;
+    }
+
+    [self destroyCompressionSession];
+
+    OSStatus status =
+      CompressionSessionCreate(nullptr,  // use default allocator
+                                 _width,
+                                 _height,
+                                 kCodecTypeH264,
+                                 encoderSpecs,
+                                 sourceAttributes,
+                                 nullptr,  // use default compressed data allocator
+                                 compressionOutputCallback,
+                                 nullptr,
+                                 &_compressionSession);
+    if (sourceAttributes) {
+      CFRelease(sourceAttributes);
+      sourceAttributes = nullptr;
+    }
+    if (encoderSpecs) {
+      CFRelease(encoderSpecs);
+      encoderSpecs = nullptr;
+    }
+    if (status != noErr) {
+      return WEBRTC_VIDEO_CODEC_ERROR;
+    }
+#endif
   }
 #endif
   [self configureCompressionSession];
-
-  // The pixel buffer pool is dependent on the compression session so if the session is reset, the
-  // pool should be reset as well.
-  _pixelBufferPool = VTCompressionSessionGetPixelBufferPool(_compressionSession);
-
   return WEBRTC_VIDEO_CODEC_OK;
 }
 
@@ -621,6 +733,10 @@ - (void)configureCompressionSession {
   SetVTSessionProperty(_compressionSession, kVTCompressionPropertyKey_RealTime, true);
   SetVTSessionProperty(_compressionSession, kVTCompressionPropertyKey_ProfileLevel, _profile);
   SetVTSessionProperty(_compressionSession, kVTCompressionPropertyKey_AllowFrameReordering, false);
+#if ENABLE_VCP_ENCODER
+  if (auto key = getkVTVideoEncoderSpecification_Usage())
+      SetVTSessionProperty(_compressionSession, (__bridge CFStringRef)key, 1);
+#endif
   [self setEncoderBitrateBps:_targetBitrateBps];
   // TODO(tkchin): Look at entropy mode and colorspace matrices.
   // TODO(tkchin): Investigate to see if there's any way to make this work.
@@ -638,10 +754,9 @@ - (void)configureCompressionSession {
 
 - (void)destroyCompressionSession {
   if (_compressionSession) {
-    VTCompressionSessionInvalidate(_compressionSession);
+    CompressionSessionInvalidate(_compressionSession);
     CFRelease(_compressionSession);
     _compressionSession = nullptr;
-    _pixelBufferPool = nullptr;
   }
 }
 
@@ -669,7 +784,7 @@ - (void)setEncoderBitrateBps:(uint32_t)bitrateBps {
         CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt64Type, &oneSecondValue);
     const void *nums[2] = {bytesPerSecond, oneSecond};
     CFArrayRef dataRateLimits = CFArrayCreate(nullptr, nums, 2, &kCFTypeArrayCallBacks);
-    OSStatus status = VTSessionSetProperty(
+    OSStatus status = CompressionSessionSetProperty(
         _compressionSession, kVTCompressionPropertyKey_DataRateLimits, dataRateLimits);
     if (bytesPerSecond) {
       CFRelease(bytesPerSecond);
@@ -681,7 +796,7 @@ - (void)setEncoderBitrateBps:(uint32_t)bitrateBps {
       CFRelease(dataRateLimits);
     }
     if (status != noErr) {
-      RTC_LOG(LS_ERROR) << "Failed to set data rate limit with code: " << status;
+      RTC_LOG(LS_ERROR) << "Failed to set data rate limit";
     }
 
     _encoderBitrateBps = bitrateBps;
@@ -698,7 +813,7 @@ - (void)frameWasEncoded:(OSStatus)status
               timestamp:(uint32_t)timestamp
                rotation:(RTCVideoRotation)rotation {
   if (status != noErr) {
-    RTC_LOG(LS_ERROR) << "H264 encode failed with code: " << status;
+    RTC_LOG(LS_ERROR) << "H264 encode failed: " << status;
     return;
   }
   if (infoFlags & kVTEncodeInfo_FrameDropped) {
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCAudioSession.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCAudioSession.h
index 15b63d39dc4..8e55852844b 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCAudioSession.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCAudioSession.h
@@ -28,6 +28,7 @@ extern NSInteger const kRTCAudioSessionErrorConfiguration;
 // from AVAudioSession and handle them before calling these delegate methods,
 // at which point applications can perform additional processing if required.
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCAudioSessionDelegate")))
 @protocol RTCAudioSessionDelegate <NSObject>
 
 @optional
@@ -103,6 +104,7 @@ RTC_EXPORT
  *  case of this is when CallKit activates the audio session for the application
  */
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCAudioSessionActivationDelegate")))
 @protocol RTCAudioSessionActivationDelegate <NSObject>
 
 /** Called when the audio session is activated outside of the app by iOS. */
@@ -121,6 +123,7 @@ RTC_EXPORT
  *  activated only once. See |setActive:error:|.
  */
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCAudioSession")))
 @interface RTCAudioSession : NSObject <RTCAudioSessionActivationDelegate>
 
 /** Convenience property to access the AVAudioSession singleton. Callers should
@@ -228,6 +231,7 @@ RTC_EXPORT
                       error:(NSError **)outError;
 @end
 
+__attribute__((objc_runtime_name("WK_RTCAudioSession")))
 @interface RTCAudioSession (Configuration)
 
 /** Applies the configuration to the current session. Attempts to set all
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCAudioSessionConfiguration.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCAudioSessionConfiguration.h
index 6a02751d294..0097246e7c8 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCAudioSessionConfiguration.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCAudioSessionConfiguration.h
@@ -23,6 +23,7 @@ extern const double kRTCAudioSessionLowComplexityIOBufferDuration;
 
 // Struct to hold configuration values.
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCAudioSessionConfiguration")))
 @interface RTCAudioSessionConfiguration : NSObject
 
 @property(nonatomic, strong) NSString *category;
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCAudioSource.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCAudioSource.h
index 3db31573cb8..7287c31a738 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCAudioSource.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCAudioSource.h
@@ -16,6 +16,7 @@
 NS_ASSUME_NONNULL_BEGIN
 
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCAudioSource")))
 @interface RTCAudioSource : RTCMediaSource
 
 - (instancetype)init NS_UNAVAILABLE;
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCAudioTrack.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCAudioTrack.h
index b83eede528c..71d797dbd75 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCAudioTrack.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCAudioTrack.h
@@ -16,6 +16,7 @@ NS_ASSUME_NONNULL_BEGIN
 @class RTCAudioSource;
 
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCMediaStreamTrack")))
 @interface RTCAudioTrack : RTCMediaStreamTrack
 
 - (instancetype)init NS_UNAVAILABLE;
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCCameraPreviewView.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCCameraPreviewView.h
index 2995c9c3b10..56ef9281729 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCCameraPreviewView.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCCameraPreviewView.h
@@ -19,6 +19,7 @@
  *  AVCaptureSession.
  */
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCCameraPreviewView")))
 @interface RTCCameraPreviewView : UIView
 
 /** The capture session being rendered in the view. Capture session
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCConfiguration.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCConfiguration.h
index 11ea6a35479..458b20c7ac9 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCConfiguration.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCConfiguration.h
@@ -69,6 +69,7 @@ typedef NS_ENUM(NSInteger, RTCSdpSemantics) {
 
 NS_ASSUME_NONNULL_BEGIN
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCConfiguration")))
 @interface RTCConfiguration : NSObject
 
 /** An array of Ice Servers available to be used by ICE. */
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCDataChannel.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCDataChannel.h
index 4859e04bdba..b525a84fc82 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCDataChannel.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCDataChannel.h
@@ -16,6 +16,7 @@
 NS_ASSUME_NONNULL_BEGIN
 
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCDataBuffer")))
 @interface RTCDataBuffer : NSObject
 
 /** NSData representation of the underlying buffer. */
@@ -60,6 +61,7 @@ typedef NS_ENUM(NSInteger, RTCDataChannelState) {
 };
 
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCDataChannel")))
 @interface RTCDataChannel : NSObject
 
 /**
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCDataChannelConfiguration.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCDataChannelConfiguration.h
index 65ca8f8d563..567e8838c65 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCDataChannelConfiguration.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCDataChannelConfiguration.h
@@ -16,6 +16,7 @@
 NS_ASSUME_NONNULL_BEGIN
 
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCDataChannelConfiguration")))
 @interface RTCDataChannelConfiguration : NSObject
 
 /** Set to YES if ordered delivery is required. */
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCDispatcher.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCDispatcher.h
index 03387471c49..5e149fce0b1 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCDispatcher.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCDispatcher.h
@@ -26,6 +26,7 @@ typedef NS_ENUM(NSInteger, RTCDispatcherQueueType) {
  *  shared dispatch queue.
  */
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCDispatcher")))
 @interface RTCDispatcher : NSObject
 
 - (instancetype)init NS_UNAVAILABLE;
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCFileLogger.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCFileLogger.h
index ac8a9104c15..a4e05a70b85 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCFileLogger.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCFileLogger.h
@@ -34,6 +34,7 @@ NS_ASSUME_NONNULL_BEGIN
 // For kRTCFileLoggerTypeApp, the oldest log is overwritten.
 // This class is not threadsafe.
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCFileLogger")))
 @interface RTCFileLogger : NSObject
 
 // The severity level to capture. The default is kRTCFileLoggerSeverityInfo.
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCIceCandidate.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCIceCandidate.h
index fb5064e5185..59083dca07c 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCIceCandidate.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCIceCandidate.h
@@ -15,6 +15,7 @@
 NS_ASSUME_NONNULL_BEGIN
 
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCIceCandidate")))
 @interface RTCIceCandidate : NSObject
 
 /**
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCIceServer.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCIceServer.h
index 727da8acbeb..d1feda40fe7 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCIceServer.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCIceServer.h
@@ -20,6 +20,7 @@ typedef NS_ENUM(NSUInteger, RTCTlsCertPolicy) {
 NS_ASSUME_NONNULL_BEGIN
 
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCIceServer")))
 @interface RTCIceServer : NSObject
 
 /** URI(s) for this server represented as NSStrings. */
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCIntervalRange.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCIntervalRange.h
index 00508eba17b..1bb27b629c7 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCIntervalRange.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCIntervalRange.h
@@ -12,6 +12,7 @@
 
 NS_ASSUME_NONNULL_BEGIN
 
+__attribute__((objc_runtime_name("WK_RTCIntervalRange")))
 @interface RTCIntervalRange : NSObject
 
 @property(nonatomic, readonly) NSInteger min;
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCLegacyStatsReport.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCLegacyStatsReport.h
index 14d996c1cec..bbc4c035f78 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCLegacyStatsReport.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCLegacyStatsReport.h
@@ -16,6 +16,7 @@ NS_ASSUME_NONNULL_BEGIN
 
 /** This does not currently conform to the spec. */
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCLegacyStatsReport")))
 @interface RTCLegacyStatsReport : NSObject
 
 /** Time since 1970-01-01T00:00:00Z in milliseconds. */
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCMediaConstraints.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCMediaConstraints.h
index fce08212e9a..8b358e9c59d 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCMediaConstraints.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCMediaConstraints.h
@@ -39,6 +39,7 @@ RTC_EXTERN NSString *const kRTCMediaConstraintsValueTrue;
 RTC_EXTERN NSString *const kRTCMediaConstraintsValueFalse;
 
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCMediaConstraints")))
 @interface RTCMediaConstraints : NSObject
 
 - (instancetype)init NS_UNAVAILABLE;
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCMediaSource.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCMediaSource.h
index 6cfcb7d2ce8..1a4003b5283 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCMediaSource.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCMediaSource.h
@@ -22,6 +22,7 @@ typedef NS_ENUM(NSInteger, RTCSourceState) {
 NS_ASSUME_NONNULL_BEGIN
 
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCMediaSource")))
 @interface RTCMediaSource : NSObject
 
 /** The current state of the RTCMediaSource. */
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCMediaStream.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCMediaStream.h
index b97960d436c..9cefde13c5f 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCMediaStream.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCMediaStream.h
@@ -19,6 +19,7 @@ NS_ASSUME_NONNULL_BEGIN
 @class RTCVideoTrack;
 
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCMediaStream")))
 @interface RTCMediaStream : NSObject
 
 /** The audio tracks in this stream. */
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCMediaStreamTrack.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCMediaStreamTrack.h
index aee9bdd0a0b..914d8f2e047 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCMediaStreamTrack.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCMediaStreamTrack.h
@@ -26,6 +26,7 @@ RTC_EXTERN NSString *const kRTCMediaStreamTrackKindAudio;
 RTC_EXTERN NSString *const kRTCMediaStreamTrackKindVideo;
 
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCMediaStreamTrack")))
 @interface RTCMediaStreamTrack : NSObject
 
 /**
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCMetricsSampleInfo.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCMetricsSampleInfo.h
index f01bea9b71b..28b71d1f9e4 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCMetricsSampleInfo.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCMetricsSampleInfo.h
@@ -15,6 +15,7 @@
 NS_ASSUME_NONNULL_BEGIN
 
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCMetricsSampleInfo")))
 @interface RTCMetricsSampleInfo : NSObject
 
 /**
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCPeerConnection.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCPeerConnection.h
index 94036cc7534..0e930c524e1 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCPeerConnection.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCPeerConnection.h
@@ -127,6 +127,7 @@ RTC_EXPORT
 @end
 
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCPeerConnection")))
 @interface RTCPeerConnection : NSObject
 
 /** The object that will be notifed about events such as state changes and
@@ -279,6 +280,7 @@ RTC_EXPORT
 
 @end
 
+__attribute__((objc_runtime_name("WK_RTCPeerConnection")))
 @interface RTCPeerConnection (Media)
 
 /** Create an RTCRtpSender with the specified kind and media stream ID.
@@ -290,6 +292,7 @@ RTC_EXPORT
 
 @end
 
+__attribute__((objc_runtime_name("WK_RTCPeerConnection")))
 @interface RTCPeerConnection (DataChannel)
 
 /** Create a new data channel with the given label and configuration. */
@@ -298,6 +301,7 @@ RTC_EXPORT
 
 @end
 
+__attribute__((objc_runtime_name("WK_RTCPeerConnection")))
 @interface RTCPeerConnection (Stats)
 
 /** Gather stats for the given RTCMediaStreamTrack. If |mediaStreamTrack| is nil
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCPeerConnectionFactory.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCPeerConnectionFactory.h
index 7f7b7e6c4c4..3fc70e65488 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCPeerConnectionFactory.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCPeerConnectionFactory.h
@@ -28,6 +28,7 @@ NS_ASSUME_NONNULL_BEGIN
 @protocol RTCVideoEncoderFactory;
 
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCPeerConnectionFactory")))
 @interface RTCPeerConnectionFactory : NSObject
 
 /* Initialize object with default H264 video encoder/decoder factories */
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCRtpCodecParameters.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCRtpCodecParameters.h
index bb9aa90507e..341e4289884 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCRtpCodecParameters.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCRtpCodecParameters.h
@@ -33,6 +33,7 @@ RTC_EXTERN const NSString *const kRTCH264CodecName;
 
 /** Defined in http://w3c.github.io/webrtc-pc/#idl-def-RTCRtpCodecParameters */
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCRtpCodecParameters")))
 @interface RTCRtpCodecParameters : NSObject
 
 /** The RTP payload type. */
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCRtpEncodingParameters.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCRtpEncodingParameters.h
index 5ba0176449d..1230e05b004 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCRtpEncodingParameters.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCRtpEncodingParameters.h
@@ -15,6 +15,7 @@
 NS_ASSUME_NONNULL_BEGIN
 
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCRtpEncodingParameters")))
 @interface RTCRtpEncodingParameters : NSObject
 
 /** Controls whether the encoding is currently transmitted. */
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCRtpParameters.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCRtpParameters.h
index 8f0993489db..ea74644f7e0 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCRtpParameters.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCRtpParameters.h
@@ -19,6 +19,7 @@
 NS_ASSUME_NONNULL_BEGIN
 
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCRtpParameters")))
 @interface RTCRtpParameters : NSObject
 
 /** A unique identifier for the last set of parameters applied. */
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCRtpReceiver.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCRtpReceiver.h
index 6156db9f932..a9b697220a2 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCRtpReceiver.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCRtpReceiver.h
@@ -73,6 +73,7 @@ RTC_EXPORT
 @end
 
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCRtpReceiver")))
 @interface RTCRtpReceiver : NSObject <RTCRtpReceiver>
 
 - (instancetype)init NS_UNAVAILABLE;
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCRtpSender.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCRtpSender.h
index f6e91250267..01ed2f749dd 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCRtpSender.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCRtpSender.h
@@ -41,6 +41,7 @@ RTC_EXPORT
 @end
 
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCRtpSender")))
 @interface RTCRtpSender : NSObject <RTCRtpSender>
 
 - (instancetype)init NS_UNAVAILABLE;
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCSessionDescription.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCSessionDescription.h
index 7db53da8bea..5ac62d67d3b 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCSessionDescription.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCSessionDescription.h
@@ -25,6 +25,7 @@ typedef NS_ENUM(NSInteger, RTCSdpType) {
 NS_ASSUME_NONNULL_BEGIN
 
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCSessionDescription")))
 @interface RTCSessionDescription : NSObject
 
 /** The type of session description. */
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoCapturer.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoCapturer.h
index f0a2eaa14c6..60151a1ac15 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoCapturer.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoCapturer.h
@@ -20,6 +20,7 @@ RTC_EXPORT
 @end
 
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCVideoCapturer")))
 @interface RTCVideoCapturer : NSObject
 
 @property(nonatomic, weak) id<RTCVideoCapturerDelegate> delegate;
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoCodec.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoCodec.h
index 5bc6d66d1ee..6fccf44fb93 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoCodec.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoCodec.h
@@ -39,6 +39,7 @@ typedef NS_ENUM(NSUInteger, RTCVideoContentType) {
 
 /** Represents an encoded frame. Corresponds to webrtc::EncodedImage. */
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCEncodedImage")))
 @interface RTCEncodedImage : NSObject
 
 @property(nonatomic, strong) NSData *buffer;
@@ -60,6 +61,7 @@ RTC_EXPORT
 
 /** Information for header. Corresponds to webrtc::RTPFragmentationHeader. */
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCRtpFragmentationHeader")))
 @interface RTCRtpFragmentationHeader : NSObject
 
 @property(nonatomic, strong) NSArray<NSNumber *> *fragmentationOffset;
@@ -92,6 +94,7 @@ typedef NS_ENUM(NSUInteger, RTCVideoCodecMode) {
 
 /** Holds information to identify a codec. Corresponds to webrtc::SdpVideoFormat. */
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCVideoCodecInfo")))
 @interface RTCVideoCodecInfo : NSObject <NSCoding>
 
 - (instancetype)init NS_UNAVAILABLE;
@@ -111,6 +114,7 @@ RTC_EXPORT
 
 /** Settings for encoder. Corresponds to webrtc::VideoCodec. */
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCVideoEncoderSettings")))
 @interface RTCVideoEncoderSettings : NSObject
 
 @property(nonatomic, strong) NSString *name;
@@ -132,6 +136,7 @@ RTC_EXPORT
 
 /** QP thresholds for encoder. Corresponds to webrtc::VideoEncoder::QpThresholds. */
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCVideoEncoderQpThresholds")))
 @interface RTCVideoEncoderQpThresholds : NSObject
 
 - (instancetype)initWithThresholdsLow:(NSInteger)low high:(NSInteger)high;
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoCodecFactory.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoCodecFactory.h
index 0ef2c8a655c..e9053025de7 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoCodecFactory.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoCodecFactory.h
@@ -39,6 +39,7 @@ RTC_EXPORT
  *  codecs, create custom implementations of RTCVideoEncoderFactory and RTCVideoDecoderFactory.
  */
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCDefaultVideoEncoderFactory")))
 @interface RTCDefaultVideoEncoderFactory : NSObject <RTCVideoEncoderFactory>
 
 @property(nonatomic, retain) RTCVideoCodecInfo *preferredCodec;
@@ -48,6 +49,7 @@ RTC_EXPORT
 @end
 
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCDefaultVideoDecoderFactory")))
 @interface RTCDefaultVideoDecoderFactory : NSObject <RTCVideoDecoderFactory>
 @end
 
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoCodecH264.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoCodecH264.h
index d4dbf88f2b6..84bf9b75028 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoCodecH264.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoCodecH264.h
@@ -20,6 +20,7 @@ typedef NS_ENUM(NSUInteger, RTCH264PacketizationMode) {
 };
 
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCCodecSpecificInfoH264")))
 @interface RTCCodecSpecificInfoH264 : NSObject <RTCCodecSpecificInfo>
 
 @property(nonatomic, assign) RTCH264PacketizationMode packetizationMode;
@@ -56,6 +57,7 @@ typedef NS_ENUM(NSUInteger, RTCH264Level) {
 };
 
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCH264ProfileLevelId")))
 @interface RTCH264ProfileLevelId : NSObject
 
 @property(nonatomic, readonly) RTCH264Profile profile;
@@ -69,6 +71,7 @@ RTC_EXPORT
 
 /** Encoder. */
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCVideoEncoderH264")))
 @interface RTCVideoEncoderH264 : NSObject <RTCVideoEncoder>
 
 - (instancetype)initWithCodecInfo:(RTCVideoCodecInfo *)codecInfo;
@@ -77,15 +80,18 @@ RTC_EXPORT
 
 /** Decoder. */
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCVideoDecoderH264")))
 @interface RTCVideoDecoderH264 : NSObject <RTCVideoDecoder>
 @end
 
 /** Encoder factory. */
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCVideoEncoderFactoryH264")))
 @interface RTCVideoEncoderFactoryH264 : NSObject <RTCVideoEncoderFactory>
 @end
 
 /** Decoder factory. */
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCVideoDecoderFactoryH264")))
 @interface RTCVideoDecoderFactoryH264 : NSObject <RTCVideoDecoderFactory>
 @end
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoDecoderVP8.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoDecoderVP8.h
index 962b6312f7f..3e19ef8909c 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoDecoderVP8.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoDecoderVP8.h
@@ -14,6 +14,7 @@
 #import <WebRTC/RTCVideoCodec.h>
 
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCVideoDecoderVP8")))
 @interface RTCVideoDecoderVP8 : NSObject
 
 /* This returns a VP8 decoder that can be returned from a RTCVideoDecoderFactory injected into
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoDecoderVP9.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoDecoderVP9.h
index faf66ef065b..3fe79bc4a52 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoDecoderVP9.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoDecoderVP9.h
@@ -14,6 +14,7 @@
 #import <WebRTC/RTCVideoCodec.h>
 
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCVideoDecoderVP9")))
 @interface RTCVideoDecoderVP9 : NSObject
 
 /* This returns a VP9 decoder that can be returned from a RTCVideoDecoderFactory injected into
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoEncoderVP8.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoEncoderVP8.h
index e63b24dde75..52155b52551 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoEncoderVP8.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoEncoderVP8.h
@@ -14,6 +14,7 @@
 #import <WebRTC/RTCVideoCodec.h>
 
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCVideoEncoderVP8")))
 @interface RTCVideoEncoderVP8 : NSObject
 
 /* This returns a VP8 encoder that can be returned from a RTCVideoEncoderFactory injected into
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoEncoderVP9.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoEncoderVP9.h
index cef8c82e96f..866e626a05e 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoEncoderVP9.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoEncoderVP9.h
@@ -14,6 +14,7 @@
 #import <WebRTC/RTCVideoCodec.h>
 
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCVideoEncoderVP9")))
 @interface RTCVideoEncoderVP9 : NSObject
 
 /* This returns a VP9 encoder that can be returned from a RTCVideoEncoderFactory injected into
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoFrame.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoFrame.h
index cfccfa9e940..809363674b4 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoFrame.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoFrame.h
@@ -26,6 +26,7 @@ typedef NS_ENUM(NSInteger, RTCVideoRotation) {
 
 // RTCVideoFrame is an ObjectiveC version of webrtc::VideoFrame.
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCVideoFrame")))
 @interface RTCVideoFrame : NSObject
 
 /** Width without rotation applied. */
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoFrameBuffer.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoFrameBuffer.h
index d590a5f7fc3..3f342536e38 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoFrameBuffer.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoFrameBuffer.h
@@ -71,6 +71,7 @@ RTC_EXPORT
 
 /** RTCVideoFrameBuffer containing a CVPixelBufferRef */
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCCVPixelBuffer")))
 @interface RTCCVPixelBuffer : NSObject <RTCVideoFrameBuffer>
 
 @property(nonatomic, readonly) CVPixelBufferRef pixelBuffer;
@@ -105,11 +106,13 @@ RTC_EXPORT
 
 /** RTCI420Buffer implements the RTCI420Buffer protocol */
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCI420Buffer")))
 @interface RTCI420Buffer : NSObject <RTCI420Buffer>
 @end
 
 /** Mutable version of RTCI420Buffer */
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCMutableI420Buffer")))
 @interface RTCMutableI420Buffer : RTCI420Buffer <RTCMutableI420Buffer>
 @end
 
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoSource.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoSource.h
index a9ebc06c88e..60075e3435a 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoSource.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoSource.h
@@ -18,6 +18,7 @@ NS_ASSUME_NONNULL_BEGIN
 
 RTC_EXPORT
 
+__attribute__((objc_runtime_name("WK_RTCVideoSource")))
 @interface RTCVideoSource : RTCMediaSource <RTCVideoCapturerDelegate>
 
 - (instancetype)init NS_UNAVAILABLE;
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoTrack.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoTrack.h
index 899d7c34780..e381c3d1e3e 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoTrack.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Headers/WebRTC/RTCVideoTrack.h
@@ -19,6 +19,7 @@ NS_ASSUME_NONNULL_BEGIN
 @class RTCVideoSource;
 
 RTC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCVideoTrack")))
 @interface RTCVideoTrack : RTCMediaStreamTrack
 
 /** The video source for this video track. */
-- 
2.17.1 (Apple Git-112)

